INF = 100000000

n = 10
m = 10
maze = [["#", "S", "#", "#", "#", "#", "#", "#", ".", "#"],
        [".", ".", ".", ".", ".", ".", "#", ".", ".", "#"],
        [".", "#", ".", "#", "#", ".", "#", "#", ".", "#"],
        [".", "#", ".", ".", ".", ".", ".", ".", ".", "."],
        ["#", "#", ".", "#", "#", ".", "#", "#", "#", "#"],
        [".", ".", ".", ".", "#", ".", ".", ".", ".", "#"],
        [".", "#", "#", "#", "#", "#", "#", "#", ".", "W"],
        [".", ".", ".", ".", "#", ".", ".", ".", ".", "."],
        [".", "#", "#", "#", "#", ".", "#", "#", "#", "."],
        [".", ".", ".", ".", "#", ".", ".", ".", "G", "#"]]

# 各点までの最短距離の配列
d = [[INF] * m for i in range(n)]

for i in range(n):
    for j in range(m):
        if maze[i][j] == "S":
            sx, sy = j, i
        elif maze[i][j] == "G":
            gx, gy = j, i

queue = [(sx, sy)]
d[sy][sx] = 0

while len(queue) > 0:
    (x, y) = queue.pop(0)
    if maze[y][x] == "G":
        break
    for (dx, dy) in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < m and 0 <= ny < n and maze[ny][nx] != "#" and d[ny][nx] == INF:
            d[ny][nx] = d[y][x] + 1
            queue.append((nx, ny))

print(d[gy][gx])
